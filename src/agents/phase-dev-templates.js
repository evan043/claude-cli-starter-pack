/**
 * Phased Development Templates
 *
 * Generic template generators for phased development plans.
 * Works with ANY tech stack - no hardcoded assumptions.
 */

/**
 * Scale definitions
 */
export const SCALE_DEFINITIONS = {
  S: {
    name: 'Small',
    phases: 2,
    taskRange: [10, 30],
    description: 'Focused feature or bug fix',
  },
  M: {
    name: 'Medium',
    phases: [3, 4],
    taskRange: [30, 80],
    description: 'Multi-component feature or refactor',
  },
  L: {
    name: 'Large',
    phases: [5, 8],
    taskRange: [80, 200],
    description: 'Major system overhaul or new module',
  },
};

/**
 * Generate PROGRESS.json structure
 */
export function generateProgressJson(config) {
  const {
    projectName,
    projectSlug,
    description,
    scale,
    phases,
    architecture = {},
    enhancements = [],
  } = config;

  const timestamp = new Date().toISOString();

  return JSON.stringify(
    {
      project: {
        name: projectName,
        slug: projectSlug,
        description,
        scale,
        created: timestamp,
        lastUpdated: timestamp,
      },
      metadata: {
        version: '2.0',
        generator: 'gtask create-phase-dev',
        successProbability: 0.95,
        enhancements,
      },
      tech_stack: {
        frontend: architecture.frontend || null,
        backend: architecture.backend || null,
        database: architecture.database || null,
        deployment: architecture.deployment || null,
        auto_detected: architecture.autoDetected || false,
      },
      phases: phases.map((phase, idx) => ({
        id: idx + 1,
        name: phase.name,
        description: phase.description,
        status: idx === 0 ? 'not_started' : 'blocked',
        prerequisites: phase.prerequisites || [],
        tasks: phase.tasks.map((task, taskIdx) => ({
          id: `${idx + 1}.${taskIdx + 1}`,
          title: task.title,
          description: task.description,
          status: 'pending',
          files: task.files || [],
          acceptance_criteria: task.acceptanceCriteria || [],
        })),
        validation: {
          criteria: phase.validationCriteria || [],
          tests: phase.tests || [],
        },
      })),
      execution_log: [],
      checkpoints: [],
    },
    null,
    2
  );
}

/**
 * Generate EXECUTIVE_SUMMARY.md
 */
export function generateExecutiveSummary(config) {
  const {
    projectName,
    projectSlug,
    description,
    scale,
    phases,
    scope,
    architecture,
  } = config;

  const scaleInfo = SCALE_DEFINITIONS[scale];
  const totalTasks = phases.reduce((sum, p) => sum + p.tasks.length, 0);

  const phaseList = phases
    .map(
      (p, i) => `
### Phase ${i + 1}: ${p.name}

**Description:** ${p.description}

**Tasks:** ${p.tasks.length}

**Key Deliverables:**
${p.tasks.slice(0, 5).map((t) => `- ${t.title}`).join('\n')}${p.tasks.length > 5 ? `\n- ... and ${p.tasks.length - 5} more` : ''}

**Validation Criteria:**
${(p.validationCriteria || ['All tasks complete', 'Tests pass']).map((c) => `- ${c}`).join('\n')}
`
    )
    .join('\n');

  return `# ${projectName} - Executive Summary

## Project Overview

**Slug:** \`${projectSlug}\`
**Scale:** ${scaleInfo.name} (${scale})
**Phases:** ${phases.length}
**Total Tasks:** ${totalTasks}
**Success Probability:** 95%+

## Description

${description}

## Scope Assessment

| Metric | Value |
|--------|-------|
| Lines of Code | ${scope?.linesOfCode || 'TBD'} |
| Components | ${scope?.components || 'TBD'} |
| Integrations | ${scope?.integrations || 'TBD'} |
| Familiarity | ${scope?.familiarity || 'TBD'} |

## Architecture

${architecture?.summary || 'See detected stack below.'}

### Technology Stack

${generateStackTable(architecture)}

## Phase Breakdown

${phaseList}

## Execution

### Start Development

\`\`\`bash
# Run the interactive command
/phase-dev-${projectSlug}

# Or execute Phase 1
/phase-dev-${projectSlug} 1
\`\`\`

### Monitor Progress

\`\`\`bash
# Check current status
cat .claude/docs/${projectSlug}/PROGRESS.json | jq '.phases[] | {name, status}'
\`\`\`

## Success Criteria

- [ ] All phases completed
- [ ] Tests pass
- [ ] No build errors
- [ ] Documentation updated

---

*Generated by gtask create-phase-dev - ${new Date().toISOString()}*
`;
}

/**
 * Generate stack table from architecture config
 */
function generateStackTable(architecture) {
  if (!architecture) return '- Not specified';

  const rows = [];

  if (architecture.frontend) {
    const fe = architecture.frontend;
    rows.push(`- **Frontend:** ${fe.framework}${fe.language === 'typescript' ? ' + TypeScript' : ''}${fe.bundler ? ` + ${fe.bundler}` : ''}`);
  }

  if (architecture.backend) {
    const be = architecture.backend;
    rows.push(`- **Backend:** ${be.framework} (${be.language})`);
  }

  if (architecture.database) {
    const db = architecture.database;
    rows.push(`- **Database:** ${db.type}${db.orm ? ` + ${db.orm}` : ''}`);
  }

  if (architecture.deployment) {
    rows.push(`- **Deployment:** ${architecture.deployment.platform}`);
  }

  return rows.length > 0 ? rows.join('\n') : '- Not specified';
}

/**
 * Generate MIDDLEWARE_SPEC.md (generic)
 */
export function generateMiddlewareSpec(config) {
  const { projectName, projectSlug, architecture = {} } = config;

  const backend = architecture.backend;
  const backendInfo = backend
    ? `${backend.framework} (${backend.language})`
    : 'Not specified';

  return `# ${projectName} - Middleware Specification

## Overview

**Backend Framework:** ${backendInfo}

## Middleware Stack

Configure your middleware based on your framework:

### 1. Request Logging

Track all incoming requests for debugging and analytics.

\`\`\`
# Add your logging middleware here
\`\`\`

### 2. Authentication

Verify user identity and permissions.

\`\`\`
# JWT validation, session handling, etc.
\`\`\`

### 3. Rate Limiting

Protect against abuse and ensure fair usage.

\`\`\`
# Configure rate limits based on your needs
\`\`\`

### 4. CORS Configuration

Control cross-origin access.

\`\`\`
# Configure allowed origins
\`\`\`

### 5. Error Handling

Consistent error response formatting.

\`\`\`
# Global error handler
\`\`\`

### 6. Validation

Request body and parameter validation.

\`\`\`
# Schema validation middleware
\`\`\`

## Middleware Order

Execute middleware in this order for best results:

1. Request logging (first - captures all requests)
2. CORS (early - reject invalid origins fast)
3. Rate limiting (early - prevent abuse)
4. Authentication (verify identity)
5. Validation (validate request data)
6. Route handlers (business logic)
7. Error handling (last - catch all errors)

## Framework-Specific Notes

*Add notes specific to your backend framework here*

---

*Reference: .claude/docs/${projectSlug}/MIDDLEWARE_SPEC.md*
`;
}

/**
 * Generate API_ENDPOINTS.md (generic)
 */
export function generateApiEndpoints(config) {
  const { projectName, projectSlug, architecture = {} } = config;

  const backend = architecture.backend;
  const backendInfo = backend
    ? `${backend.framework} (${backend.language})`
    : 'Not specified';

  return `# ${projectName} - API Endpoints

## Overview

**Backend Framework:** ${backendInfo}

## Base URL

Configure your base URL in environment variables:

\`\`\`
# Development
API_URL=http://localhost:3000/api

# Production
API_URL=https://your-domain.com/api
\`\`\`

## Authentication

Define your authentication strategy here:

- JWT Bearer tokens
- API keys
- Session-based auth
- OAuth 2.0

## Endpoints

*Define your endpoints here as you build them:*

### Example Endpoint

\`\`\`
GET /api/health
\`\`\`

**Response:**
\`\`\`json
{
  "status": "ok",
  "timestamp": "2024-01-01T00:00:00Z"
}
\`\`\`

## Error Responses

All errors should follow a consistent structure:

\`\`\`json
{
  "error": true,
  "code": "ERROR_CODE",
  "message": "Human-readable message",
  "details": {}
}
\`\`\`

---

*Reference: .claude/docs/${projectSlug}/API_ENDPOINTS.md*
`;
}

/**
 * Generate DATABASE_SCHEMA.md (generic)
 */
export function generateDatabaseSchema(config) {
  const { projectName, projectSlug, architecture = {} } = config;

  const database = architecture.database;
  const dbType = database?.type || 'Not specified';
  const orm = database?.orm || 'Not specified';

  return `# ${projectName} - Database Schema

## Overview

**Database:** ${dbType}
**ORM/Driver:** ${orm}

## Configuration

Set your database connection in environment variables:

\`\`\`
DATABASE_URL=your-connection-string-here
\`\`\`

## Tables / Collections

*Define your schema here as you build it:*

### Example Table

| Column | Type | Constraints |
|--------|------|-------------|
| id | UUID/ObjectId | PRIMARY KEY |
| created_at | TIMESTAMP | DEFAULT NOW() |
| updated_at | TIMESTAMP | DEFAULT NOW() |

## Migrations

Document your migration strategy:

- Migration tool: (Prisma/TypeORM/Alembic/etc.)
- Migration location: \`/migrations\` or \`/prisma\`

## Indexes

*List important indexes for query optimization*

## Relationships

*Document entity relationships*

---

*Reference: .claude/docs/${projectSlug}/DATABASE_SCHEMA.md*
`;
}

/**
 * Generate DEPLOYMENT_CONFIG.md (generic)
 */
export function generateDeploymentConfig(config) {
  const { projectName, projectSlug, architecture = {} } = config;

  const deployment = architecture.deployment;
  const platform = deployment?.platform || 'Not specified';

  return `# ${projectName} - Deployment Configuration

## Platform

**Target Platform:** ${platform}

## Environment Variables

### Required Variables

\`\`\`
# Add your required environment variables here
NODE_ENV=production
DATABASE_URL=
API_URL=
\`\`\`

### Optional Variables

\`\`\`
# Add optional configuration here
LOG_LEVEL=info
ENABLE_ANALYTICS=true
\`\`\`

## Deployment Steps

1. Build the application
2. Run database migrations
3. Deploy to ${platform}
4. Verify health checks
5. Update DNS if needed

## Deployment Commands

*Add your deployment commands here:*

\`\`\`bash
# Example build command
npm run build

# Example deploy command
# Your platform-specific deploy command here
\`\`\`

## Rollback Procedure

1. Identify the issue
2. Revert to previous deployment
3. Investigate root cause
4. Deploy fix

## Monitoring

- Health check endpoint: \`/api/health\`
- Logs: Configure your logging service
- Alerts: Set up monitoring for critical metrics

---

*Reference: .claude/docs/${projectSlug}/DEPLOYMENT_CONFIG.md*
`;
}

/**
 * Generate RAG Phase Executor Agent
 */
export function generatePhaseExecutorAgent(config) {
  const { projectName, projectSlug, phases, architecture } = config;

  const phaseChecks = phases
    .map(
      (p, i) => `
### Phase ${i + 1}: ${p.name}

**Status Check:**
\`\`\`bash
cat .claude/docs/${projectSlug}/PROGRESS.json | jq '.phases[${i}]'
\`\`\`

**Tasks:**
${p.tasks.map((t, j) => `${i + 1}.${j + 1}. ${t.title}`).join('\n')}

**Validation:**
${(p.validationCriteria || ['All tasks complete']).map((c) => `- ${c}`).join('\n')}
`
    )
    .join('\n');

  return `---
name: ${projectSlug}-phase-executor
description: Autonomous phase executor for ${projectName}
level: L1
tools: Task, Read, Write, Edit, Grep, Glob, Bash
model: sonnet
capabilities:
  - token_monitoring
  - context_compaction
  - state_persistence
  - auto_respawn
---

# ${projectName} - Phase Executor Agent

Autonomous agent for executing phased development of ${projectName}.

## Tech Stack

${architecture?.summary || 'See PROGRESS.json for detected stack'}

## Activation

This agent activates when:
- User runs \`/phase-dev-${projectSlug}\`
- User requests work on "${projectName}"
- PROGRESS.json shows incomplete phases

## State Management

**Progress File:** \`.claude/docs/${projectSlug}/PROGRESS.json\`

### Read Current State

\`\`\`bash
cat .claude/docs/${projectSlug}/PROGRESS.json | jq '.phases[] | {id, name, status}'
\`\`\`

### Update Task Status

When completing a task, update PROGRESS.json:
1. Set task status to "completed"
2. Add entry to execution_log
3. Update phase status if all tasks done

## Workflow

### Phase Execution Protocol

1. **Read PROGRESS.json** - Identify current phase and pending tasks
2. **Check Prerequisites** - Ensure previous phases are complete
3. **Execute Tasks** - Work through tasks sequentially
4. **Validate** - Run validation criteria after each task
5. **Update Progress** - Mark tasks/phases complete
6. **Report** - Summarize what was done

### Token Management

| Threshold | Action |
|-----------|--------|
| 75% | Compact context, save state |
| 90% | Create checkpoint, prepare handoff |
| 95% | Force save, spawn continuation |

## Phase Details

${phaseChecks}

## Completion Protocol

When all phases complete:
1. Update PROGRESS.json with completion timestamp
2. Run final validation suite
3. Generate completion report
4. Suggest next steps

---

*Generated by gtask create-phase-dev - ${new Date().toISOString()}*
`;
}

/**
 * Generate interactive slash command
 */
export function generatePhaseDevCommand(config) {
  const { projectName, projectSlug, phases } = config;

  const phaseOptions = phases
    .map((p, i) => `  - **${i + 1}** - Execute Phase ${i + 1}: ${p.name}`)
    .join('\n');

  return `---
description: Interactive phased development menu for ${projectName}
type: project
complexity: high
---

# /phase-dev-${projectSlug}

Interactive phased development execution for ${projectName}.

## Usage

\`\`\`bash
/phase-dev-${projectSlug}           # Show menu
/phase-dev-${projectSlug} 1         # Execute Phase 1
/phase-dev-${projectSlug} status    # Check progress
\`\`\`

## Quick Actions

| Key | Action |
|-----|--------|
| 1-${phases.length} | Execute specific phase |
| S | Show status |
| V | Validate current phase |
| C | Create checkpoint |
| X | Exit |

## Phases

${phaseOptions}

## Instructions

When this command is invoked:

### Step 1: Load Progress

Read \`.claude/docs/${projectSlug}/PROGRESS.json\` to understand current state.

### Step 2: Display Menu

Show phase status and available actions.

### Step 3: Execute Selection

Based on user selection:
- **Phase execution**: Load phase executor agent
- **Status**: Display current progress
- **Validate**: Run validation criteria

### Step 4: Update Progress

After any action, update PROGRESS.json with:
- Task completions
- Execution log entries
- Timestamps

## Related

- \`.claude/docs/${projectSlug}/EXECUTIVE_SUMMARY.md\` - Overview
- \`.claude/docs/${projectSlug}/PROGRESS.json\` - State tracking

---

*Created by gtask create-phase-dev - ${new Date().toISOString()}*
`;
}

/**
 * Generate TEST_DEFINITIONS.json
 */
export function generateTestDefinitions(config) {
  const { projectSlug, phases, architecture = {} } = config;

  const testing = architecture.testing || {};
  const testFramework = testing.framework || 'jest';
  const e2eFramework = testing.e2e || 'playwright';
  const extension = testing.framework === 'vitest' || architecture.frontend?.language === 'typescript' ? '.ts' : '.js';

  const testSuites = phases.map((phase, phaseIdx) => ({
    phase: phaseIdx + 1,
    name: phase.name,
    tests: phase.tasks.map((task, taskIdx) => ({
      id: `test-${phaseIdx + 1}-${taskIdx + 1}`,
      task: `${phaseIdx + 1}.${taskIdx + 1}`,
      title: `Test: ${task.title}`,
      type: task.testType || 'unit',
      file: `tests/phase${phaseIdx + 1}/${projectSlug}.spec${extension}`,
      criteria: task.acceptanceCriteria || [],
    })),
  }));

  return JSON.stringify(
    {
      project: projectSlug,
      generated: new Date().toISOString(),
      frameworks: {
        unit: testFramework,
        e2e: e2eFramework,
      },
      suites: testSuites,
      coverage: {
        target: 80,
        unit: true,
        integration: true,
        e2e: true,
      },
    },
    null,
    2
  );
}

/**
 * Generate enforcement hook (optional, generic)
 */
export function generatePhaseDevEnforcerHook(config) {
  const { projectSlug, projectName } = config;

  return `#!/usr/bin/env node
/**
 * ${projectName} - Phase Development Enforcer
 *
 * Event: PreToolUse (Edit|Write)
 * Purpose: Track file changes during phased development
 *
 * Created by: gtask create-phase-dev
 * Date: ${new Date().toISOString()}
 */

const fs = require('fs');
const path = require('path');

const hookInput = JSON.parse(process.env.CLAUDE_HOOK_INPUT || '{}');

// Configuration - customize these patterns for your project
const CONFIG = {
  projectSlug: '${projectSlug}',
  progressFile: '.claude/docs/${projectSlug}/PROGRESS.json',

  // Add patterns to warn about (optional)
  warningPatterns: [
    // Example: 'TODO', 'FIXME', 'HACK'
  ],

  // Add patterns to block (optional)
  blockedPatterns: [
    // Example: 'console.log' in production code
  ],
};

async function main() {
  try {
    const tool = hookInput.tool_name || '';
    const input = hookInput.tool_input || {};

    // Only check Edit and Write
    if (!['Edit', 'Write'].includes(tool)) {
      console.log(JSON.stringify({ decision: 'approve' }));
      return;
    }

    const content = input.content || input.new_string || '';
    const filePath = input.file_path || '';

    // Log file changes to progress (optional)
    // You can customize this to track which files were modified

    // Check for blocked patterns (if any defined)
    if (CONFIG.blockedPatterns.length > 0) {
      const blocked = CONFIG.blockedPatterns.filter(p => content.includes(p));
      if (blocked.length > 0) {
        console.log(JSON.stringify({
          decision: 'block',
          reason: 'Pattern violation',
          systemMessage: \`Blocked patterns found: \${blocked.join(', ')}\`
        }));
        process.exit(1);
        return;
      }
    }

    // Check for warning patterns (if any defined)
    if (CONFIG.warningPatterns.length > 0) {
      const warnings = CONFIG.warningPatterns.filter(p => content.includes(p));
      if (warnings.length > 0) {
        console.log(JSON.stringify({
          decision: 'approve',
          systemMessage: \`Warning - patterns found: \${warnings.join(', ')}\`
        }));
        return;
      }
    }

    // All checks passed
    console.log(JSON.stringify({ decision: 'approve' }));

  } catch (error) {
    // Fail-safe: approve on error
    console.log(JSON.stringify({
      decision: 'approve',
      reason: \`Hook error (non-blocking): \${error.message}\`
    }));
  }
}

main();
`;
}

/**
 * Small project phase templates (generic)
 */
export const SMALL_PHASE_TEMPLATES = [
  {
    name: 'Foundation',
    description: 'Core implementation and setup',
    taskTemplates: [
      'Set up project structure',
      'Implement core functionality',
      'Add basic validation',
      'Create unit tests',
    ],
  },
  {
    name: 'Polish & Deploy',
    description: 'Refinement and deployment',
    taskTemplates: [
      'Add error handling',
      'Implement UI polish',
      'Run tests',
      'Deploy to environment',
    ],
  },
];

/**
 * Medium project phase templates (generic)
 */
export const MEDIUM_PHASE_TEMPLATES = [
  {
    name: 'Foundation',
    description: 'Setup and core architecture',
    taskTemplates: [
      'Set up project structure',
      'Configure development environment',
      'Implement data layer',
      'Set up API structure',
    ],
  },
  {
    name: 'Core Features',
    description: 'Main functionality implementation',
    taskTemplates: [
      'Build primary UI components',
      'Implement business logic',
      'Add state management',
      'Create integration tests',
    ],
  },
  {
    name: 'Integration',
    description: 'Connect components and test',
    taskTemplates: [
      'Wire frontend to backend',
      'Add real-time features (if needed)',
      'Implement caching',
      'Run E2E tests',
    ],
  },
  {
    name: 'Polish & Deploy',
    description: 'Final touches and deployment',
    taskTemplates: [
      'UI/UX refinements',
      'Performance optimization',
      'Documentation',
      'Production deployment',
    ],
  },
];

/**
 * Large project phase templates (generic)
 */
export const LARGE_PHASE_TEMPLATES = [
  {
    name: 'Architecture',
    description: 'System design and infrastructure',
    taskTemplates: [
      'Define system architecture',
      'Design data model',
      'Plan API structure',
      'Set up CI/CD pipeline',
    ],
  },
  {
    name: 'Data Layer',
    description: 'Database and data access',
    taskTemplates: [
      'Create database schema',
      'Implement data access layer',
      'Add data validation',
      'Set up caching layer',
    ],
  },
  {
    name: 'API Layer',
    description: 'Backend endpoints and services',
    taskTemplates: [
      'Build REST/GraphQL endpoints',
      'Add real-time support (if needed)',
      'Implement middleware',
      'Create API documentation',
    ],
  },
  {
    name: 'Core UI',
    description: 'Primary user interface',
    taskTemplates: [
      'Build core components',
      'Implement navigation',
      'Add form handling',
      'Create state management',
    ],
  },
  {
    name: 'Features',
    description: 'Feature-specific implementation',
    taskTemplates: [
      'Implement feature modules',
      'Add business logic',
      'Create feature tests',
      'Wire to backend',
    ],
  },
  {
    name: 'Integration',
    description: 'System integration and testing',
    taskTemplates: [
      'End-to-end integration',
      'Performance testing',
      'Security review',
      'Load testing',
    ],
  },
  {
    name: 'Polish',
    description: 'Refinement and optimization',
    taskTemplates: [
      'UI/UX improvements',
      'Accessibility audit',
      'Mobile optimization',
      'Documentation',
    ],
  },
  {
    name: 'Launch',
    description: 'Deployment and monitoring',
    taskTemplates: [
      'Staging deployment',
      'Production deployment',
      'Monitoring setup',
      'Post-launch support',
    ],
  },
];
