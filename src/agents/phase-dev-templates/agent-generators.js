/**
 * Agent and command generators for phased development plans.
 * Generates agent definitions, slash commands, test definitions, and hooks.
 */

/**
 * Generate RAG Phase Executor Agent
 */
export function generatePhaseExecutorAgent(config) {
  const { projectName, projectSlug, phases, architecture } = config;

  const phaseChecks = phases
    .map(
      (p, i) => `
### Phase ${i + 1}: ${p.name}

**Status Check:**
\`\`\`bash
cat .claude/docs/${projectSlug}/PROGRESS.json | jq '.phases[${i}]'
\`\`\`

**Tasks:**
${p.tasks.map((t, j) => `${i + 1}.${j + 1}. ${t.title}`).join('\n')}

**Validation:**
${(p.validationCriteria || ['All tasks complete']).map((c) => `- ${c}`).join('\n')}
`
    )
    .join('\n');

  return `---
name: ${projectSlug}-phase-executor
description: Autonomous phase executor for ${projectName}
level: L1
tools: Task, Read, Write, Edit, Grep, Glob, Bash
capabilities:
  - token_monitoring
  - context_compaction
  - state_persistence
  - auto_respawn
---

# ${projectName} - Phase Executor Agent

Autonomous agent for executing phased development of ${projectName}.

## Tech Stack

${architecture?.summary || 'See PROGRESS.json for detected stack'}

## Activation

This agent activates when:
- User runs \`/phase-dev-${projectSlug}\`
- User requests work on "${projectName}"
- PROGRESS.json shows incomplete phases

## State Management

**Progress File:** \`.claude/docs/${projectSlug}/PROGRESS.json\`

### Read Current State

\`\`\`bash
cat .claude/docs/${projectSlug}/PROGRESS.json | jq '.phases[] | {id, name, status}'
\`\`\`

### Update Task Status

When completing a task, update PROGRESS.json:
1. Set task status to "completed"
2. Add entry to execution_log
3. Update phase status if all tasks done

## Workflow

### Phase Execution Protocol

1. **Read PROGRESS.json** - Identify current phase and pending tasks
2. **Check Prerequisites** - Ensure previous phases are complete
3. **Execute Tasks** - Work through tasks sequentially
4. **Validate** - Run validation criteria after each task
5. **Update Progress** - Mark tasks/phases complete
6. **Report** - Summarize what was done

### Token Management

| Threshold | Action |
|-----------|--------|
| 75% | Compact context, save state |
| 90% | Create checkpoint, prepare handoff |
| 95% | Force save, spawn continuation |

## Phase Details

${phaseChecks}

## Completion Protocol

When all phases complete:
1. Update PROGRESS.json with completion timestamp
2. Run final validation suite
3. Generate completion report
4. Suggest next steps

---

*Generated by gtask create-phase-dev - ${new Date().toISOString()}*
`;
}

/**
 * Generate interactive slash command
 */
export function generatePhaseDevCommand(config) {
  const { projectName, projectSlug, phases } = config;

  const phaseOptions = phases
    .map((p, i) => `  - **${i + 1}** - Execute Phase ${i + 1}: ${p.name}`)
    .join('\n');

  return `---
description: Interactive phased development menu for ${projectName}
type: project
complexity: high
---

# /phase-dev-${projectSlug}

Interactive phased development execution for ${projectName}.

## Usage

\`\`\`bash
/phase-dev-${projectSlug}           # Show menu
/phase-dev-${projectSlug} 1         # Execute Phase 1
/phase-dev-${projectSlug} status    # Check progress
\`\`\`

## Quick Actions

| Key | Action |
|-----|--------|
| 1-${phases.length} | Execute specific phase |
| S | Show status |
| V | Validate current phase |
| C | Create checkpoint |
| X | Exit |

## Phases

${phaseOptions}

## Instructions

When this command is invoked:

### Step 1: Load Progress

Read \`.claude/docs/${projectSlug}/PROGRESS.json\` to understand current state.

### Step 2: Display Menu

Show phase status and available actions.

### Step 3: Execute Selection

Based on user selection:
- **Phase execution**: Load phase executor agent
- **Status**: Display current progress
- **Validate**: Run validation criteria

### Step 4: Update Progress

After any action, update PROGRESS.json with:
- Task completions
- Execution log entries
- Timestamps

## Related

- \`.claude/docs/${projectSlug}/EXECUTIVE_SUMMARY.md\` - Overview
- \`.claude/docs/${projectSlug}/PROGRESS.json\` - State tracking

---

*Created by gtask create-phase-dev - ${new Date().toISOString()}*
`;
}

/**
 * Generate TEST_DEFINITIONS.json
 */
export function generateTestDefinitions(config) {
  const { projectSlug, phases, architecture = {} } = config;

  const testing = architecture.testing || {};
  const testFramework = testing.framework || 'jest';
  const e2eFramework = testing.e2e || 'playwright';
  const extension = testing.framework === 'vitest' || architecture.frontend?.language === 'typescript' ? '.ts' : '.js';

  const testSuites = phases.map((phase, phaseIdx) => ({
    phase: phaseIdx + 1,
    name: phase.name,
    tests: phase.tasks.map((task, taskIdx) => ({
      id: `test-${phaseIdx + 1}-${taskIdx + 1}`,
      task: `${phaseIdx + 1}.${taskIdx + 1}`,
      title: `Test: ${task.title}`,
      type: task.testType || 'unit',
      file: `tests/phase${phaseIdx + 1}/${projectSlug}.spec${extension}`,
      criteria: task.acceptanceCriteria || [],
    })),
  }));

  return JSON.stringify(
    {
      project: projectSlug,
      generated: new Date().toISOString(),
      frameworks: {
        unit: testFramework,
        e2e: e2eFramework,
      },
      suites: testSuites,
      coverage: {
        target: 80,
        unit: true,
        integration: true,
        e2e: true,
      },
    },
    null,
    2
  );
}

/**
 * Generate enforcement hook (optional, generic)
 */
export function generatePhaseDevEnforcerHook(config) {
  const { projectSlug, projectName } = config;

  return `#!/usr/bin/env node
/**
 * ${projectName} - Phase Development Enforcer
 *
 * Event: PreToolUse (Edit|Write)
 * Purpose: Track file changes during phased development
 *
 * Created by: gtask create-phase-dev
 * Date: ${new Date().toISOString()}
 */

const fs = require('fs');
const path = require('path');

const hookInput = JSON.parse(process.env.CLAUDE_HOOK_INPUT || '{}');

// Configuration - customize these patterns for your project
const CONFIG = {
  projectSlug: '${projectSlug}',
  progressFile: '.claude/docs/${projectSlug}/PROGRESS.json',

  // Add patterns to warn about (optional)
  warningPatterns: [
    // Example: 'TODO', 'FIXME', 'HACK'
  ],

  // Add patterns to block (optional)
  blockedPatterns: [
    // Example: 'console.log' in production code
  ],
};

async function main() {
  try {
    const tool = hookInput.tool_name || '';
    const input = hookInput.tool_input || {};

    // Only check Edit and Write
    if (!['Edit', 'Write'].includes(tool)) {
      console.log(JSON.stringify({ decision: 'approve' }));
      return;
    }

    const content = input.content || input.new_string || '';
    const filePath = input.file_path || '';

    // Log file changes to progress (optional)
    // You can customize this to track which files were modified

    // Check for blocked patterns (if any defined)
    if (CONFIG.blockedPatterns.length > 0) {
      const blocked = CONFIG.blockedPatterns.filter(p => content.includes(p));
      if (blocked.length > 0) {
        console.log(JSON.stringify({
          decision: 'block',
          reason: 'Pattern violation',
          systemMessage: \`Blocked patterns found: \${blocked.join(', ')}\`
        }));
        process.exit(1);
        return;
      }
    }

    // Check for warning patterns (if any defined)
    if (CONFIG.warningPatterns.length > 0) {
      const warnings = CONFIG.warningPatterns.filter(p => content.includes(p));
      if (warnings.length > 0) {
        console.log(JSON.stringify({
          decision: 'approve',
          systemMessage: \`Warning - patterns found: \${warnings.join(', ')}\`
        }));
        return;
      }
    }

    // All checks passed
    console.log(JSON.stringify({ decision: 'approve' }));

  } catch (error) {
    // Fail-safe: approve on error
    console.log(JSON.stringify({
      decision: 'approve',
      reason: \`Hook error (non-blocking): \${error.message}\`
    }));
  }
}

main();
`;
}
