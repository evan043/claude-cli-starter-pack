/**
 * CLAUDE.md Updater
 *
 * Updates CLAUDE.md with MCP server documentation.
 * Adds tool references and usage examples for installed MCPs.
 */

import chalk from 'chalk';
import ora from 'ora';
import { existsSync, readFileSync, writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';

/**
 * MCP section marker
 */
const MCP_SECTION_START = '<!-- MCP-SERVERS-START -->';
const MCP_SECTION_END = '<!-- MCP-SERVERS-END -->';

/**
 * Generate MCP documentation section
 *
 * @param {Array} installedMcps - Array of installed MCP definitions
 * @returns {string} Markdown documentation
 */
export function generateMcpDocumentation(installedMcps) {
  if (installedMcps.length === 0) {
    return `
${MCP_SECTION_START}
## MCP Servers

No MCP servers configured. Run \`gtask explore-mcp\` to discover and install MCP servers.
${MCP_SECTION_END}
`;
  }

  const sections = installedMcps.map((mcp) => {
    const tools = mcp.tools?.slice(0, 5).join(', ') || 'See documentation';
    const hasMoreTools = mcp.tools?.length > 5;

    return `### ${mcp.name}

**ID:** \`${mcp.id}\`
**Category:** ${mcp.category}

${mcp.description}

**Key Tools:** ${tools}${hasMoreTools ? ` (+${mcp.tools.length - 5} more)` : ''}

${mcp.note ? `> **Note:** ${mcp.note}` : ''}`;
  });

  // Group by category
  const byCategory = {};
  for (const mcp of installedMcps) {
    const cat = mcp.category || 'other';
    if (!byCategory[cat]) byCategory[cat] = [];
    byCategory[cat].push(mcp);
  }

  const categorySections = Object.entries(byCategory)
    .map(([category, mcps]) => {
      const categoryName = category.charAt(0).toUpperCase() + category.slice(1);
      const mcpDocs = mcps
        .map((mcp) => {
          const tools = mcp.tools?.slice(0, 3).join(', ') || 'See docs';
          return `| ${mcp.name} | \`${mcp.id}\` | ${tools} |`;
        })
        .join('\n');

      return `### ${categoryName}

| Server | ID | Key Tools |
|--------|----|-----------|
${mcpDocs}`;
    })
    .join('\n\n');

  return `
${MCP_SECTION_START}
## MCP Servers

MCP (Model Context Protocol) servers extend Claude's capabilities. These are configured in \`.mcp.json\`.

${categorySections}

### Usage

MCP tools are accessed via the \`ToolSearch\` tool or directly if loaded:

\`\`\`
# Search for MCP tools
ToolSearch query: "playwright screenshot"

# Use directly (after loading)
mcp__playwright__browser_screenshot
\`\`\`

### Restart Required

After modifying \`.mcp.json\`, restart Claude Code for changes to take effect:

\`\`\`bash
# Exit and re-enter the project
cd .. && cd your-project
\`\`\`

*Generated by gtask explore-mcp*
${MCP_SECTION_END}
`;
}

/**
 * Load CLAUDE.md content
 */
export function loadClaudeMd(cwd = process.cwd()) {
  const claudeMdPath = join(cwd, 'CLAUDE.md');

  if (existsSync(claudeMdPath)) {
    return readFileSync(claudeMdPath, 'utf8');
  }

  return null;
}

/**
 * Update CLAUDE.md with MCP documentation
 *
 * @param {Array} installedMcps - Array of installed MCP definitions
 * @param {Object} options - Options
 * @returns {Object} Update result
 */
export async function updateClaudeMd(installedMcps, options = {}) {
  const spinner = ora('Updating CLAUDE.md...').start();
  const cwd = options.cwd || process.cwd();
  const claudeMdPath = join(cwd, 'CLAUDE.md');

  try {
    // Generate new MCP section
    const mcpSection = generateMcpDocumentation(installedMcps);

    let content = loadClaudeMd(cwd);

    if (!content) {
      // No CLAUDE.md exists - create minimal one with MCP section
      spinner.text = 'Creating CLAUDE.md...';
      content = `# Project

<!-- Project-specific instructions for Claude Code -->

${mcpSection}
`;
      writeFileSync(claudeMdPath, content, 'utf8');
      spinner.succeed('Created CLAUDE.md with MCP documentation');
      return {
        success: true,
        action: 'created',
        path: claudeMdPath,
      };
    }

    // Check if MCP section exists
    const hasStartMarker = content.includes(MCP_SECTION_START);
    const hasEndMarker = content.includes(MCP_SECTION_END);

    if (hasStartMarker && hasEndMarker) {
      // Replace existing section
      spinner.text = 'Replacing existing MCP section...';
      const regex = new RegExp(
        `${MCP_SECTION_START}[\\s\\S]*?${MCP_SECTION_END}`,
        'g'
      );
      content = content.replace(regex, mcpSection.trim());
    } else {
      // Append to end
      spinner.text = 'Appending MCP section...';

      // Find good insertion point (before any existing sections like "---" at end)
      const lines = content.split('\n');
      let insertIndex = lines.length;

      // Look for common ending patterns
      for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i].trim();
        if (line === '---' || line.startsWith('*Generated') || line.startsWith('<!-- ')) {
          insertIndex = i;
        } else if (line.length > 0) {
          break;
        }
      }

      lines.splice(insertIndex, 0, '', mcpSection.trim(), '');
      content = lines.join('\n');
    }

    writeFileSync(claudeMdPath, content, 'utf8');
    spinner.succeed('Updated CLAUDE.md with MCP documentation');

    return {
      success: true,
      action: hasStartMarker ? 'updated' : 'appended',
      path: claudeMdPath,
    };
  } catch (error) {
    spinner.fail(`Failed to update CLAUDE.md: ${error.message}`);
    return {
      success: false,
      error: error.message,
    };
  }
}

/**
 * Remove MCP section from CLAUDE.md
 */
export function removeMcpSection(cwd = process.cwd()) {
  const claudeMdPath = join(cwd, 'CLAUDE.md');

  if (!existsSync(claudeMdPath)) {
    return false;
  }

  let content = readFileSync(claudeMdPath, 'utf8');

  const hasStartMarker = content.includes(MCP_SECTION_START);
  const hasEndMarker = content.includes(MCP_SECTION_END);

  if (hasStartMarker && hasEndMarker) {
    const regex = new RegExp(
      `\\n?${MCP_SECTION_START}[\\s\\S]*?${MCP_SECTION_END}\\n?`,
      'g'
    );
    content = content.replace(regex, '\n');
    writeFileSync(claudeMdPath, content, 'utf8');
    return true;
  }

  return false;
}

/**
 * Generate a quick-reference comment for MCP tools
 */
export function generateMcpQuickRef(installedMcps) {
  const lines = ['<!-- MCP Quick Reference'];

  for (const mcp of installedMcps) {
    lines.push(`  ${mcp.id}: ${mcp.tools?.slice(0, 3).join(', ') || 'see docs'}`);
  }

  lines.push('-->');
  return lines.join('\n');
}
