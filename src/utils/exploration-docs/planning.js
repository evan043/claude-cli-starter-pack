/**
 * Planning documentation generation for exploration docs
 */

import { writeFileSync } from 'fs';
import { join } from 'path';
import { createExplorationDir } from './directory.js';

/**
 * Format dependencies for display
 */
function formatDependencies(deps) {
  if (!deps || deps.length === 0) return 'None';
  return deps.join(', ');
}

/**
 * Generate phase breakdown markdown content
 * @param {string} slug - Project slug
 * @param {Array} phases - Array of phase objects
 * @returns {string} Markdown content
 */
export function generatePhaseBreakdownMarkdown(slug, phases) {
  let content = `# Phase Breakdown: ${slug}

`;

  if (!phases || phases.length === 0) {
    content += '*No phases defined.*\n';
    return content;
  }

  phases.forEach((phase, phaseIdx) => {
    const phaseNum = phaseIdx + 1;
    const tasks = phase.tasks || [];
    const validationCriteria = phase.validationCriteria || phase.validation?.criteria || [];

    content += `## Phase ${phaseNum}: ${phase.name || phase.phase_title || 'Untitled'}
**Objective:** ${phase.objective || phase.description || phase.goal || 'Not specified'}
**Complexity:** ${phase.complexity || 'M'}
**Estimated Tasks:** ${tasks.length}
**Assigned Agent:** ${phase.assignedAgent || phase.agents_assigned?.[0] || 'TBD'}
**Dependencies:** ${formatDependencies(phase.dependencies || phase.prerequisites)}

### Tasks

`;

    if (tasks.length === 0) {
      content += '*No tasks defined for this phase.*\n\n';
    } else {
      tasks.forEach((task, taskIdx) => {
        const taskId = task.id || `${phaseNum}.${taskIdx + 1}`;
        const taskFiles = task.files || [];
        const modifyFiles = taskFiles.filter(f => f.relevance === 'primary' || f.modify);
        const refFiles = taskFiles.filter(f => f.relevance === 'reference' || f.reference);

        content += `#### Task ${taskId}: ${task.title || task.subject || 'Untitled'}
- **Description:** ${task.description || 'Not specified'}
- **Files:**
`;

        if (modifyFiles.length > 0) {
          modifyFiles.forEach(f => {
            content += `  - Modify: \`${f.path}\` - ${f.reason || 'Primary implementation'}\n`;
          });
        }
        if (refFiles.length > 0) {
          refFiles.forEach(f => {
            content += `  - Reference: \`${f.path}\` - ${f.reason || 'Dependency'}\n`;
          });
        }
        if (modifyFiles.length === 0 && refFiles.length === 0) {
          content += '  - *No specific files identified*\n';
        }

        if (task.codePatternRef) {
          content += `- **Code Pattern:** See [${task.codePatternRef}](./CODE_SNIPPETS.md#${task.codePatternRef.toLowerCase().replace(/\s+/g, '-')})\n`;
        }

        content += '- **Acceptance Criteria:**\n';
        const criteria = task.acceptanceCriteria || task.acceptance_criteria || [];
        if (criteria.length > 0) {
          criteria.forEach(c => {
            content += `  - [ ] ${c}\n`;
          });
        } else {
          content += '  - [ ] Implementation complete\n';
        }

        content += `- **Assigned Agent:** ${task.assignedAgent || phase.assignedAgent || 'TBD'}\n`;

        const blockedBy = task.blockedBy || task.blocked_by || [];
        const blocks = task.blocks || [];
        if (blockedBy.length > 0) {
          content += `- **Blocked By:** ${blockedBy.join(', ')}\n`;
        }
        if (blocks.length > 0) {
          content += `- **Blocks:** ${blocks.join(', ')}\n`;
        }

        content += '\n';
      });
    }

    content += `### Phase ${phaseNum} Validation
`;
    if (validationCriteria.length > 0) {
      validationCriteria.forEach(c => {
        content += `- [ ] ${c}\n`;
      });
    } else {
      content += '- [ ] All tasks complete\n- [ ] No blocking issues\n';
    }

    content += '\n---\n';
  });

  content += `

---
*Generated by CCASP L2 Exploration*
`;

  return content;
}

/**
 * Save phase breakdown markdown (CRITICAL - Full Detail)
 * @param {string} slug - Project slug
 * @param {Array} phases - Array of phase objects with full task breakdown
 * @param {string} cwd - Current working directory
 */
export function savePhaseBreakdown(slug, phases, cwd = process.cwd()) {
  const dir = createExplorationDir(slug, cwd);
  const content = generatePhaseBreakdownMarkdown(slug, phases);
  writeFileSync(join(dir, 'PHASE_BREAKDOWN.md'), content, 'utf8');
  return join(dir, 'PHASE_BREAKDOWN.md');
}
