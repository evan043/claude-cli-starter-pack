/**
 * Exploration Documentation Utilities
 *
 * Shared utilities for saving L2 exploration findings as markdown files.
 * Used by both /phase-dev-plan and /create-roadmap commands.
 *
 * Directory structure:
 * .claude/exploration/{slug}/
 *   ├── EXPLORATION_SUMMARY.md
 *   ├── CODE_SNIPPETS.md
 *   ├── REFERENCE_FILES.md
 *   ├── AGENT_DELEGATION.md
 *   ├── PHASE_BREAKDOWN.md
 *   └── findings.json
 */

import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'fs';
import { join } from 'path';

/**
 * Create exploration directory structure
 * @param {string} slug - Project slug (kebab-case)
 * @param {string} cwd - Current working directory (default: process.cwd())
 * @returns {string} Path to exploration directory
 */
export function createExplorationDir(slug, cwd = process.cwd()) {
  const explorationDir = join(cwd, '.claude', 'exploration', slug);

  if (!existsSync(explorationDir)) {
    mkdirSync(explorationDir, { recursive: true });
  }

  return explorationDir;
}

/**
 * Get exploration directory path
 * @param {string} slug - Project slug
 * @param {string} cwd - Current working directory
 * @returns {string} Path to exploration directory
 */
export function getExplorationDir(slug, cwd = process.cwd()) {
  return join(cwd, '.claude', 'exploration', slug);
}

/**
 * Save exploration summary markdown
 * @param {string} slug - Project slug
 * @param {Object} summary - Summary data
 * @param {string} cwd - Current working directory
 */
export function saveExplorationSummary(slug, summary, cwd = process.cwd()) {
  const dir = createExplorationDir(slug, cwd);
  const timestamp = new Date().toISOString();

  const content = `# Exploration Summary: ${summary.title || slug}

**Generated:** ${timestamp}
**Status:** ${summary.status || 'complete'}
**Confidence:** ${summary.confidence || 'medium'}

## Overview
${summary.overview || 'No overview provided.'}

## Key Statistics
- Files analyzed: ${summary.filesAnalyzed || 0}
- Code snippets extracted: ${summary.snippetsExtracted || 0}
- Phases identified: ${summary.phasesIdentified || 0}
- Tasks generated: ${summary.tasksGenerated || 0}
- Recommended agents: ${(summary.recommendedAgents || []).join(', ') || 'None'}

## Quick Reference
- [Code Snippets](./CODE_SNIPPETS.md)
- [Reference Files](./REFERENCE_FILES.md)
- [Agent Delegation](./AGENT_DELEGATION.md)
- [Phase Breakdown](./PHASE_BREAKDOWN.md)

## Domain Distribution
${summary.domains ? formatDomainDistribution(summary.domains) : '- Not analyzed'}

## Complexity Assessment
${summary.complexityAssessment || '- Not assessed'}

---
*Generated by CCASP L2 Exploration*
`;

  writeFileSync(join(dir, 'EXPLORATION_SUMMARY.md'), content, 'utf8');
  return join(dir, 'EXPLORATION_SUMMARY.md');
}

/**
 * Format domain distribution for markdown
 */
function formatDomainDistribution(domains) {
  if (!domains || Object.keys(domains).length === 0) return '- No domains detected';

  return Object.entries(domains)
    .map(([domain, count]) => `- **${domain}:** ${count} items`)
    .join('\n');
}

/**
 * Save code snippets markdown
 * @param {string} slug - Project slug
 * @param {Array} snippets - Array of snippet objects
 * @param {string} cwd - Current working directory
 */
export function saveCodeSnippets(slug, snippets, cwd = process.cwd()) {
  const dir = createExplorationDir(slug, cwd);

  let content = `# Code Snippets: ${slug}

`;

  if (!snippets || snippets.length === 0) {
    content += '*No code snippets extracted.*\n';
  } else {
    snippets.forEach((snippet, idx) => {
      content += `## Snippet ${idx + 1}: ${snippet.description || 'Untitled'}
**File:** \`${snippet.file || 'unknown'}\`
**Lines:** ${snippet.startLine || '?'}-${snippet.endLine || '?'}
**Relevance:** ${snippet.relevance || 'General reference'}

\`\`\`${snippet.language || ''}
${snippet.content || '// No content'}
\`\`\`

---
`;
    });
  }

  writeFileSync(join(dir, 'CODE_SNIPPETS.md'), content, 'utf8');
  return join(dir, 'CODE_SNIPPETS.md');
}

/**
 * Save reference files markdown
 * @param {string} slug - Project slug
 * @param {Object} files - Files object with modify, reference, tests arrays
 * @param {string} cwd - Current working directory
 */
export function saveReferenceFiles(slug, files, cwd = process.cwd()) {
  const dir = createExplorationDir(slug, cwd);

  const modifyFiles = files.modify || [];
  const referenceFiles = files.reference || [];
  const testFiles = files.tests || [];

  let content = `# Reference Files: ${slug}

## Files to MODIFY (Primary)
| File | Reason | Complexity |
|------|--------|------------|
`;

  if (modifyFiles.length === 0) {
    content += '| *No files identified* | - | - |\n';
  } else {
    modifyFiles.forEach(f => {
      content += `| \`${f.path}\` | ${f.reason || '-'} | ${f.complexity || 'M'} |\n`;
    });
  }

  content += `
## Files to REFERENCE (Dependencies)
| File | Reason |
|------|--------|
`;

  if (referenceFiles.length === 0) {
    content += '| *No dependencies identified* | - |\n';
  } else {
    referenceFiles.forEach(f => {
      content += `| \`${f.path}\` | ${f.reason || '-'} |\n`;
    });
  }

  content += `
## Test Files to UPDATE
| File | Coverage Area |
|------|---------------|
`;

  if (testFiles.length === 0) {
    content += '| *No test files identified* | - |\n';
  } else {
    testFiles.forEach(f => {
      content += `| \`${f.path}\` | ${f.coverage || '-'} |\n`;
    });
  }

  content += `
---
*Generated by CCASP L2 Exploration*
`;

  writeFileSync(join(dir, 'REFERENCE_FILES.md'), content, 'utf8');
  return join(dir, 'REFERENCE_FILES.md');
}

/**
 * Save agent delegation markdown
 * @param {string} slug - Project slug
 * @param {Object} delegation - Delegation configuration
 * @param {string} cwd - Current working directory
 */
export function saveAgentDelegation(slug, delegation, cwd = process.cwd()) {
  const dir = createExplorationDir(slug, cwd);

  const primaryAgent = delegation.primaryAgent || 'general-implementation-agent';
  const taskAssignments = delegation.taskAssignments || [];
  const executionSequence = delegation.executionSequence || [];

  let content = `# Agent Delegation: ${slug}

## Recommended Primary Agent
**${primaryAgent}** - ${delegation.primaryAgentReason || 'Best fit for overall project domain'}

## Task-Agent Assignments
| Phase | Task | Recommended Agent | Reason |
|-------|------|-------------------|--------|
`;

  if (taskAssignments.length === 0) {
    content += '| - | - | *No assignments* | - |\n';
  } else {
    taskAssignments.forEach(a => {
      content += `| ${a.phase || '-'} | ${a.task || '-'} | ${a.agent || '-'} | ${a.reason || '-'} |\n`;
    });
  }

  content += `
## Execution Sequence
`;

  if (executionSequence.length === 0) {
    content += '*No specific sequence defined - follow phase order.*\n';
  } else {
    executionSequence.forEach((seq, idx) => {
      content += `${idx + 1}. **${seq.agent}** - ${seq.scope || 'General'}\n`;
    });
  }

  content += `
## Agent Capabilities Reference
| Agent | Domains | Tools |
|-------|---------|-------|
| frontend-specialist | UI, Components, Styling | Read, Write, Edit, Glob, Grep |
| backend-specialist | API, Database, Auth | Read, Write, Edit, Bash, Glob |
| testing-specialist | Unit, E2E, Coverage | Read, Write, Bash, Glob |
| deployment-specialist | CI/CD, Docker, Cloud | Read, Bash, Glob |
| general-implementation | Full-stack | All tools |

---
*Generated by CCASP L2 Exploration*
`;

  writeFileSync(join(dir, 'AGENT_DELEGATION.md'), content, 'utf8');
  return join(dir, 'AGENT_DELEGATION.md');
}

/**
 * Save phase breakdown markdown (CRITICAL - Full Detail)
 * @param {string} slug - Project slug
 * @param {Array} phases - Array of phase objects with full task breakdown
 * @param {string} cwd - Current working directory
 */
export function savePhaseBreakdown(slug, phases, cwd = process.cwd()) {
  const dir = createExplorationDir(slug, cwd);
  const content = generatePhaseBreakdownMarkdown(slug, phases);
  writeFileSync(join(dir, 'PHASE_BREAKDOWN.md'), content, 'utf8');
  return join(dir, 'PHASE_BREAKDOWN.md');
}

/**
 * Generate phase breakdown markdown content
 * @param {string} slug - Project slug
 * @param {Array} phases - Array of phase objects
 * @returns {string} Markdown content
 */
export function generatePhaseBreakdownMarkdown(slug, phases) {
  let content = `# Phase Breakdown: ${slug}

`;

  if (!phases || phases.length === 0) {
    content += '*No phases defined.*\n';
    return content;
  }

  phases.forEach((phase, phaseIdx) => {
    const phaseNum = phaseIdx + 1;
    const tasks = phase.tasks || [];
    const validationCriteria = phase.validationCriteria || phase.validation?.criteria || [];

    content += `## Phase ${phaseNum}: ${phase.name || phase.phase_title || 'Untitled'}
**Objective:** ${phase.objective || phase.description || phase.goal || 'Not specified'}
**Complexity:** ${phase.complexity || 'M'}
**Estimated Tasks:** ${tasks.length}
**Assigned Agent:** ${phase.assignedAgent || phase.agents_assigned?.[0] || 'TBD'}
**Dependencies:** ${formatDependencies(phase.dependencies || phase.prerequisites)}

### Tasks

`;

    if (tasks.length === 0) {
      content += '*No tasks defined for this phase.*\n\n';
    } else {
      tasks.forEach((task, taskIdx) => {
        const taskId = task.id || `${phaseNum}.${taskIdx + 1}`;
        const taskFiles = task.files || [];
        const modifyFiles = taskFiles.filter(f => f.relevance === 'primary' || f.modify);
        const refFiles = taskFiles.filter(f => f.relevance === 'reference' || f.reference);

        content += `#### Task ${taskId}: ${task.title || task.subject || 'Untitled'}
- **Description:** ${task.description || 'Not specified'}
- **Files:**
`;

        if (modifyFiles.length > 0) {
          modifyFiles.forEach(f => {
            content += `  - Modify: \`${f.path}\` - ${f.reason || 'Primary implementation'}\n`;
          });
        }
        if (refFiles.length > 0) {
          refFiles.forEach(f => {
            content += `  - Reference: \`${f.path}\` - ${f.reason || 'Dependency'}\n`;
          });
        }
        if (modifyFiles.length === 0 && refFiles.length === 0) {
          content += '  - *No specific files identified*\n';
        }

        if (task.codePatternRef) {
          content += `- **Code Pattern:** See [${task.codePatternRef}](./CODE_SNIPPETS.md#${task.codePatternRef.toLowerCase().replace(/\s+/g, '-')})\n`;
        }

        content += '- **Acceptance Criteria:**\n';
        const criteria = task.acceptanceCriteria || task.acceptance_criteria || [];
        if (criteria.length > 0) {
          criteria.forEach(c => {
            content += `  - [ ] ${c}\n`;
          });
        } else {
          content += '  - [ ] Implementation complete\n';
        }

        content += `- **Assigned Agent:** ${task.assignedAgent || phase.assignedAgent || 'TBD'}\n`;

        const blockedBy = task.blockedBy || task.blocked_by || [];
        const blocks = task.blocks || [];
        if (blockedBy.length > 0) {
          content += `- **Blocked By:** ${blockedBy.join(', ')}\n`;
        }
        if (blocks.length > 0) {
          content += `- **Blocks:** ${blocks.join(', ')}\n`;
        }

        content += '\n';
      });
    }

    content += `### Phase ${phaseNum} Validation
`;
    if (validationCriteria.length > 0) {
      validationCriteria.forEach(c => {
        content += `- [ ] ${c}\n`;
      });
    } else {
      content += '- [ ] All tasks complete\n- [ ] No blocking issues\n';
    }

    content += '\n---\n';
  });

  content += `
---
*Generated by CCASP L2 Exploration*
`;

  return content;
}

/**
 * Format dependencies for display
 */
function formatDependencies(deps) {
  if (!deps || deps.length === 0) return 'None';
  return deps.join(', ');
}

/**
 * Save machine-readable findings JSON
 * @param {string} slug - Project slug
 * @param {Object} findings - Complete findings object
 * @param {string} cwd - Current working directory
 */
export function saveFindingsJson(slug, findings, cwd = process.cwd()) {
  const dir = createExplorationDir(slug, cwd);

  const enrichedFindings = {
    ...findings,
    metadata: {
      ...(findings.metadata || {}),
      slug,
      generatedAt: new Date().toISOString(),
      version: '1.0',
      generator: 'ccasp-l2-exploration',
    },
  };

  writeFileSync(
    join(dir, 'findings.json'),
    JSON.stringify(enrichedFindings, null, 2),
    'utf8'
  );

  return join(dir, 'findings.json');
}

/**
 * Load all exploration docs for execution phase
 * @param {string} slug - Project slug
 * @param {string} cwd - Current working directory
 * @returns {Object|null} Loaded exploration data or null if not found
 */
export function loadExplorationDocs(slug, cwd = process.cwd()) {
  const dir = getExplorationDir(slug, cwd);

  if (!existsSync(dir)) {
    return null;
  }

  const result = {
    slug,
    path: dir,
    exists: true,
  };

  // Load findings.json (machine-readable)
  const findingsPath = join(dir, 'findings.json');
  if (existsSync(findingsPath)) {
    try {
      result.findings = JSON.parse(readFileSync(findingsPath, 'utf8'));
    } catch {
      result.findings = null;
    }
  }

  // Load markdown files (for reference/display)
  const mdFiles = [
    'EXPLORATION_SUMMARY.md',
    'CODE_SNIPPETS.md',
    'REFERENCE_FILES.md',
    'AGENT_DELEGATION.md',
    'PHASE_BREAKDOWN.md',
  ];

  result.markdownFiles = {};
  for (const file of mdFiles) {
    const filePath = join(dir, file);
    if (existsSync(filePath)) {
      try {
        result.markdownFiles[file] = readFileSync(filePath, 'utf8');
      } catch {
        result.markdownFiles[file] = null;
      }
    }
  }

  return result;
}

/**
 * Check if exploration docs exist for a slug
 * @param {string} slug - Project slug
 * @param {string} cwd - Current working directory
 * @returns {boolean} True if exploration docs exist
 */
export function explorationDocsExist(slug, cwd = process.cwd()) {
  const findingsPath = join(getExplorationDir(slug, cwd), 'findings.json');
  return existsSync(findingsPath);
}

/**
 * Save all exploration documentation at once
 * @param {string} slug - Project slug
 * @param {Object} explorationData - Complete exploration data
 * @param {string} cwd - Current working directory
 * @returns {Object} Paths to generated files
 */
export function saveAllExplorationDocs(slug, explorationData, cwd = process.cwd()) {
  const paths = {};

  // Save summary
  paths.summary = saveExplorationSummary(slug, explorationData.summary || {}, cwd);

  // Save code snippets
  paths.snippets = saveCodeSnippets(slug, explorationData.snippets || [], cwd);

  // Save reference files
  paths.referenceFiles = saveReferenceFiles(slug, explorationData.files || {}, cwd);

  // Save agent delegation
  paths.delegation = saveAgentDelegation(slug, explorationData.delegation || {}, cwd);

  // Save phase breakdown
  paths.phases = savePhaseBreakdown(slug, explorationData.phases || [], cwd);

  // Save JSON findings
  paths.json = saveFindingsJson(slug, explorationData, cwd);

  return {
    success: true,
    directory: getExplorationDir(slug, cwd),
    files: paths,
  };
}

export default {
  createExplorationDir,
  getExplorationDir,
  saveExplorationSummary,
  saveCodeSnippets,
  saveReferenceFiles,
  saveAgentDelegation,
  savePhaseBreakdown,
  saveFindingsJson,
  loadExplorationDocs,
  explorationDocsExist,
  saveAllExplorationDocs,
  generatePhaseBreakdownMarkdown,
};
