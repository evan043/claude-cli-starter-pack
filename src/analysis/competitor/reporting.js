/**
 * Competitor Analysis Reporting
 *
 * Functions for generating reports, saving/loading analysis data,
 * and checking MCP availability.
 */

import { existsSync, readFileSync, writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';

/**
 * Get report output directory
 * @param {string} projectRoot - Project root
 * @returns {string} Report directory path
 */
export function getReportDir(projectRoot = process.cwd()) {
  return join(projectRoot, 'docs', 'competitive-analysis');
}

/**
 * Generate markdown report
 * @param {object} analysis - Complete analysis data
 * @returns {string} Markdown report
 */
export function generateMarkdownReport(analysis) {
  const {
    productName,
    domain,
    generatedAt,
    competitors = [],
    featureGapMatrix,
    swot,
  } = analysis;

  let report = `# Competitive Analysis: ${productName}

**Domain:** ${domain}
**Generated:** ${generatedAt}
**Competitors Analyzed:** ${competitors.length}

---

## Executive Summary

${analysis.executiveSummary || 'Analysis in progress...'}

---

## Competitors

`;

  // Competitor profiles
  for (const competitor of competitors) {
    report += `### ${competitor.name}

**Website:** ${competitor.website || 'N/A'}
**Description:** ${competitor.description || 'N/A'}

**Pricing Model:** ${competitor.pricing?.model || 'Unknown'}
${competitor.pricing?.hasFreeTier ? '✓ Has free tier' : '✗ No free tier'}
${competitor.pricing?.startingPrice ? `Starting at: ${competitor.pricing.startingPrice}` : ''}

**Key Features:**
${(competitor.features || []).slice(0, 10).map(f => `- ${f.name || f}`).join('\n') || '- Not yet analyzed'}

**Sentiment:**
- Rating: ${competitor.sentiment?.overallRating || 'N/A'}
- Reviews: ${competitor.sentiment?.reviewCount || 0}

---

`;
  }

  // Feature gap matrix
  if (featureGapMatrix) {
    report += `## Feature Gap Analysis

### Gaps to Address (Features Competitors Have)

| Priority | Feature | Competitor Coverage |
|----------|---------|---------------------|
${featureGapMatrix.summary.gaps.map(g =>
  `| ${g.priority} | ${g.feature} | ${g.competitorCoverage} |`
).join('\n') || '| - | No significant gaps identified | - |'}

### Our Differentiators

${featureGapMatrix.summary.opportunities.map(o =>
  `- **${o.feature}** ${o.differentiator ? '(Unique to us!)' : ''}`
).join('\n') || '- Analysis in progress...'}

---

`;
  }

  // SWOT
  if (swot) {
    report += `## SWOT Analysis

### Strengths
${swot.strengths.map(s => `- ${s}`).join('\n') || '- (To be identified)'}

### Weaknesses
${swot.weaknesses.map(w => `- ${w}`).join('\n') || '- (To be identified)'}

### Opportunities
${swot.opportunities.map(o => `- ${o}`).join('\n') || '- (To be identified)'}

### Threats
${swot.threats.map(t => `- ${t}`).join('\n') || '- (To be identified)'}

---

`;
  }

  report += `## Recommendations

${analysis.recommendations || '(Recommendations will be generated after full analysis)'}

---

*Generated by CCASP Competitor Analysis*
`;

  return report;
}

/**
 * Save analysis report
 * @param {object} analysis - Analysis data
 * @param {string} projectRoot - Project root
 * @returns {string} Path to saved report
 */
export function saveReport(analysis, projectRoot = process.cwd()) {
  const reportDir = getReportDir(projectRoot);

  if (!existsSync(reportDir)) {
    mkdirSync(reportDir, { recursive: true });
  }

  const slug = analysis.productName.toLowerCase().replace(/\s+/g, '-');
  const date = new Date().toISOString().split('T')[0];

  // Save markdown report
  const mdPath = join(reportDir, `${slug}-analysis-${date}.md`);
  writeFileSync(mdPath, generateMarkdownReport(analysis), 'utf8');

  // Save JSON data
  const jsonPath = join(reportDir, `${slug}-analysis-${date}.json`);
  writeFileSync(jsonPath, JSON.stringify(analysis, null, 2), 'utf8');

  return mdPath;
}

/**
 * Load existing analysis
 * @param {string} productName - Product name
 * @param {string} projectRoot - Project root
 * @returns {object|null} Analysis data or null
 */
export function loadAnalysis(productName, projectRoot = process.cwd()) {
  const reportDir = getReportDir(projectRoot);
  const slug = productName.toLowerCase().replace(/\s+/g, '-');

  // Find most recent analysis
  try {
    const files = require('fs').readdirSync(reportDir);
    const jsonFiles = files
      .filter(f => f.startsWith(slug) && f.endsWith('.json'))
      .sort()
      .reverse();

    if (jsonFiles.length > 0) {
      return JSON.parse(readFileSync(join(reportDir, jsonFiles[0]), 'utf8'));
    }
  } catch {
    return null;
  }

  return null;
}

/**
 * Check MCP availability for competitor analysis
 * @returns {object} Available MCPs
 */
export function checkMcpAvailability() {
  // This would be called by the agent to check what tools are available
  return {
    search: {
      duckduckgo: false,
      openWebsearch: false,
      websearch: true, // Always available
    },
    scraping: {
      crawl4ai: false,
      webfetch: true, // Always available
    },
    recommendation: 'Using built-in WebSearch and WebFetch. For enhanced analysis, consider installing Crawl4AI (uvx crawl4ai-mcp).',
  };
}
