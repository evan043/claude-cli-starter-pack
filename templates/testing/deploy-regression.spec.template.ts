/**
 * Deploy Regression Tests
 *
 * Validates API contracts haven't drifted after a deploy.
 * Uses Playwright's request API context (no browser needed).
 *
 * Placeholders:
 *   {{API_BASE}}    - Base URL for API (e.g. https://api.example.com)
 *   {{ENDPOINTS}}   - JSON array of endpoint configs
 *   {{AUTH_HEADER}} - Authorization header value (e.g. Bearer <token>)
 *
 * Generated by /create-smoke-test (CCASP)
 */
import { test, expect } from '@playwright/test';

const API_BASE = '{{API_BASE}}';
const AUTH_HEADER = '{{AUTH_HEADER}}';

// Each endpoint: { method, path, expectedStatus, requiredFields?, description? }
const ENDPOINTS: Array<{
  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
  path: string;
  expectedStatus: number;
  requiredFields?: string[];
  description?: string;
}> = {{ENDPOINTS}};

test.describe('Deploy Regression - API Contract Validation', () => {
  test.describe('Endpoint existence', () => {
    for (const ep of ENDPOINTS) {
      test(`${ep.method} ${ep.path} returns ${ep.expectedStatus}`, async ({ request }) => {
        const url = `${API_BASE}${ep.path}`;
        const headers: Record<string, string> = {};
        if (AUTH_HEADER) {
          headers['Authorization'] = AUTH_HEADER;
        }

        const response = await request[ep.method.toLowerCase() as 'get'](url, { headers });

        expect(response.status(), `${ep.description ?? ep.path} status mismatch`).toBe(
          ep.expectedStatus
        );
      });
    }
  });

  test.describe('Response shape validation', () => {
    for (const ep of ENDPOINTS.filter((e) => e.requiredFields?.length)) {
      test(`${ep.method} ${ep.path} has required fields: ${ep.requiredFields!.join(', ')}`, async ({
        request,
      }) => {
        const url = `${API_BASE}${ep.path}`;
        const headers: Record<string, string> = {};
        if (AUTH_HEADER) {
          headers['Authorization'] = AUTH_HEADER;
        }

        const response = await request[ep.method.toLowerCase() as 'get'](url, { headers });
        const body = await response.json();

        // Handle both object and array responses
        const obj = Array.isArray(body) ? body[0] : body;
        if (!obj) {
          // Empty array is valid - skip field check
          return;
        }

        for (const field of ep.requiredFields!) {
          // Support nested fields with dot notation
          const value = field.split('.').reduce((o: any, k) => o?.[k], obj);
          expect(value, `Missing field "${field}" in ${ep.path}`).toBeDefined();
        }
      });
    }
  });

  test.describe('Error handling contracts', () => {
    test('unknown endpoint returns 404', async ({ request }) => {
      const response = await request.get(`${API_BASE}/api/v1/__nonexistent_route__`);
      expect(response.status()).toBe(404);
    });

    test('malformed request body returns 4xx', async ({ request }) => {
      // Find a POST endpoint to test against
      const postEndpoint = ENDPOINTS.find((e) => e.method === 'POST');
      if (!postEndpoint) {
        test.skip();
        return;
      }

      const headers: Record<string, string> = { 'Content-Type': 'application/json' };
      if (AUTH_HEADER) {
        headers['Authorization'] = AUTH_HEADER;
      }

      const response = await request.post(`${API_BASE}${postEndpoint.path}`, {
        headers,
        data: '{ invalid json',
      });

      expect(response.status()).toBeGreaterThanOrEqual(400);
      expect(response.status()).toBeLessThan(500);
    });
  });

  test.describe('CORS headers', () => {
    test('API responds with CORS headers on preflight', async ({ request }) => {
      // Simulate preflight request
      const ep = ENDPOINTS[0];
      if (!ep) {
        test.skip();
        return;
      }

      const response = await request.fetch(`${API_BASE}${ep.path}`, {
        method: 'OPTIONS',
        headers: {
          Origin: 'https://example.com',
          'Access-Control-Request-Method': 'GET',
        },
      });

      // Should not be 405 Method Not Allowed
      expect(response.status()).not.toBe(405);

      const headers = response.headers();
      const corsHeader =
        headers['access-control-allow-origin'] ?? headers['access-control-allow-methods'];
      expect(corsHeader, 'CORS headers missing from preflight response').toBeTruthy();
    });
  });

  test.describe('Pagination contracts', () => {
    test('GET endpoints accept limit/offset params without error', async ({ request }) => {
      const getEndpoints = ENDPOINTS.filter((e) => e.method === 'GET');
      for (const ep of getEndpoints.slice(0, 3)) {
        const sep = ep.path.includes('?') ? '&' : '?';
        const url = `${API_BASE}${ep.path}${sep}limit=1&offset=0`;
        const headers: Record<string, string> = {};
        if (AUTH_HEADER) {
          headers['Authorization'] = AUTH_HEADER;
        }

        const response = await request.get(url, { headers });

        // Should return success or the original status - not 500
        expect(response.status(), `${ep.path} broke with pagination params`).toBeLessThan(500);
      }
    });
  });
});
