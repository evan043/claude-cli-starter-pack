/**
 * Auth Flow Tests
 *
 * Validates the complete authentication lifecycle in the browser.
 * Tests cookie/token handling, session persistence, guards, and refresh.
 *
 * Placeholders:
 *   {{LOGIN_URL}}        - Login page path (e.g. /login)
 *   {{PROTECTED_ROUTES}}  - JSON array of paths that require auth
 *   {{CREDENTIALS}}       - JSON { email, password } for a test user
 *   {{COOKIE_NAME}}       - Auth cookie name (e.g. token, session_id)
 *
 * Generated by /create-smoke-test (CCASP)
 */
import { test, expect, type Page, type BrowserContext } from '@playwright/test';

const LOGIN_URL = '{{LOGIN_URL}}';
const COOKIE_NAME = '{{COOKIE_NAME}}';
const CREDENTIALS = {{CREDENTIALS}};
const PROTECTED_ROUTES: string[] = {{PROTECTED_ROUTES}};

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

async function fillLoginForm(page: Page, email: string, password: string) {
  await page.goto(LOGIN_URL);
  await page.waitForLoadState('networkidle');

  // Try common selectors - adapt to your app
  const emailInput =
    page.locator('[data-testid="email-input"]')
      .or(page.locator('input[type="email"]'))
      .or(page.locator('input[name="email"]'));
  const passwordInput =
    page.locator('[data-testid="password-input"]')
      .or(page.locator('input[type="password"]'))
      .or(page.locator('input[name="password"]'));
  const submitBtn =
    page.locator('[data-testid="login-button"]')
      .or(page.locator('button[type="submit"]'));

  await emailInput.first().fill(email);
  await passwordInput.first().fill(password);
  await submitBtn.first().click();
}

async function getAuthCookie(context: BrowserContext): Promise<string | undefined> {
  const cookies = await context.cookies();
  return cookies.find((c) => c.name === COOKIE_NAME)?.value;
}

async function getAuthToken(page: Page): Promise<string | null> {
  return page.evaluate((cookieName) => {
    // Check localStorage
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i)!;
      if (key.toLowerCase().includes('token') || key.toLowerCase().includes('auth')) {
        return localStorage.getItem(key);
      }
    }
    // Check sessionStorage
    for (let i = 0; i < sessionStorage.length; i++) {
      const key = sessionStorage.key(i)!;
      if (key.toLowerCase().includes('token') || key.toLowerCase().includes('auth')) {
        return sessionStorage.getItem(key);
      }
    }
    return null;
  }, COOKIE_NAME);
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

test.describe('Auth Flow - Login & Session Lifecycle', () => {
  test('login with valid credentials sets auth cookie/token', async ({ page, context }) => {
    await fillLoginForm(page, CREDENTIALS.email, CREDENTIALS.password);

    // Wait for navigation away from login page
    await page.waitForURL((url) => !url.pathname.includes('login'), { timeout: 10_000 });

    // Verify auth state was set (cookie OR localStorage token)
    const cookie = await getAuthCookie(context);
    const token = await getAuthToken(page);
    expect(cookie || token, 'No auth cookie or token found after login').toBeTruthy();
  });

  test('session persists across page reload', async ({ page, context }) => {
    // Login first
    await fillLoginForm(page, CREDENTIALS.email, CREDENTIALS.password);
    await page.waitForURL((url) => !url.pathname.includes('login'), { timeout: 10_000 });

    // Capture current URL (should be a protected page)
    const urlAfterLogin = page.url();

    // Reload
    await page.reload();
    await page.waitForLoadState('networkidle');

    // Should NOT be redirected back to login
    expect(page.url()).not.toContain('login');

    // Auth state should still exist
    const cookie = await getAuthCookie(context);
    const token = await getAuthToken(page);
    expect(cookie || token, 'Auth state lost after reload').toBeTruthy();
  });

  test('invalid credentials show error message', async ({ page }) => {
    await fillLoginForm(page, 'invalid@nonexistent.test', 'wrongpassword123');

    // Should stay on login page
    await page.waitForTimeout(2000);
    expect(page.url()).toContain('login');

    // Should show an error (check common patterns)
    const errorVisible = await page
      .locator('[data-testid="error-message"], [role="alert"], .error, .toast-error')
      .first()
      .isVisible()
      .catch(() => false);

    expect(errorVisible, 'No error message shown for invalid credentials').toBe(true);
  });

  test.describe('Protected route guards', () => {
    for (const route of PROTECTED_ROUTES) {
      test(`${route} redirects to login when unauthenticated`, async ({ page }) => {
        // Clear all auth state
        await page.context().clearCookies();

        // Navigate directly to protected route
        await page.goto(route);
        await page.waitForLoadState('networkidle');

        // Should be on login page or a redirect
        const url = page.url();
        const isOnLogin = url.includes('login') || url.includes('signin') || url.includes('auth');
        expect(isOnLogin, `${route} accessible without auth - guard missing`).toBe(true);
      });
    }
  });

  test('logout clears auth state', async ({ page, context }) => {
    // Login first
    await fillLoginForm(page, CREDENTIALS.email, CREDENTIALS.password);
    await page.waitForURL((url) => !url.pathname.includes('login'), { timeout: 10_000 });

    // Find and click logout
    const logoutBtn = page
      .locator('[data-testid="logout-button"]')
      .or(page.locator('button:has-text("Logout")'))
      .or(page.locator('button:has-text("Sign out")'))
      .or(page.locator('a:has-text("Logout")'));

    if (await logoutBtn.first().isVisible().catch(() => false)) {
      await logoutBtn.first().click();
      await page.waitForLoadState('networkidle');

      // Auth state should be cleared
      const cookie = await getAuthCookie(context);
      const token = await getAuthToken(page);
      expect(!cookie && !token, 'Auth state not cleared after logout').toBe(true);

      // Should be on login page or home
      const url = page.url();
      const isOnPublicPage =
        url.includes('login') || url.includes('signin') || url.endsWith('/');
      expect(isOnPublicPage, 'Not redirected to public page after logout').toBe(true);
    } else {
      test.skip();
    }
  });

  test('expired token triggers refresh (no infinite redirect loop)', async ({ page, context }) => {
    // Login first
    await fillLoginForm(page, CREDENTIALS.email, CREDENTIALS.password);
    await page.waitForURL((url) => !url.pathname.includes('login'), { timeout: 10_000 });

    // Tamper with auth cookie to simulate expiry
    const cookies = await context.cookies();
    const authCookie = cookies.find((c) => c.name === COOKIE_NAME);
    if (authCookie) {
      await context.addCookies([
        { ...authCookie, value: 'expired_invalid_token_value' },
      ]);
    }

    // Track navigation count to detect redirect loops
    let navigationCount = 0;
    page.on('framenavigated', () => navigationCount++);

    // Navigate to a protected route
    const targetRoute = PROTECTED_ROUTES[0] ?? '/';
    await page.goto(targetRoute);
    await page.waitForLoadState('networkidle');

    // Wait a moment for any redirect chains to settle
    await page.waitForTimeout(3000);

    // Should not have more than 3 navigations (initial + possible refresh + final)
    expect(navigationCount, 'Possible redirect loop detected').toBeLessThanOrEqual(5);

    // Should end up on either the target page (refresh worked) or login (refresh failed)
    const finalUrl = page.url();
    const validDestination =
      finalUrl.includes(targetRoute) ||
      finalUrl.includes('login') ||
      finalUrl.includes('signin');
    expect(validDestination, `Ended up on unexpected page: ${finalUrl}`).toBe(true);
  });
});
