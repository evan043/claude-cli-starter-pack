/**
 * Route Loading Tests
 *
 * Validates every route renders without JS errors or blank screens.
 * Catches lazy import failures, chunk loading errors, and performance regressions.
 *
 * Placeholders:
 *   {{ROUTES}}       - JSON array of { path, name?, authenticated? }
 *   {{BASE_URL}}     - Application base URL (e.g. http://localhost:5174)
 *   {{LOAD_TIMEOUT}} - Max ms to wait for route content (e.g. 10000)
 *
 * Generated by /create-smoke-test (CCASP)
 */
import { test, expect, type Page } from '@playwright/test';

const BASE_URL = '{{BASE_URL}}';
const LOAD_TIMEOUT = {{LOAD_TIMEOUT}};

const ROUTES: Array<{
  path: string;
  name?: string;
  authenticated?: boolean;
}> = {{ROUTES}};

// ---------------------------------------------------------------------------
// Fixtures & Helpers
// ---------------------------------------------------------------------------

/** Collect JS console errors during page lifecycle */
function attachErrorListener(page: Page): string[] {
  const errors: string[] = [];
  page.on('console', (msg) => {
    if (msg.type() === 'error') {
      errors.push(msg.text());
    }
  });
  page.on('pageerror', (err) => {
    errors.push(err.message);
  });
  return errors;
}

/** Check if page has meaningful content (not blank/empty) */
async function hasVisibleContent(page: Page): Promise<boolean> {
  // Wait for body to have children
  const bodyChildCount = await page.evaluate(() => document.body.children.length);
  if (bodyChildCount === 0) return false;

  // Check that there's text content or meaningful elements
  const textLength = await page.evaluate(() => {
    const text = document.body.innerText?.trim() ?? '';
    // Exclude common "empty" states
    return text.replace(/loading|spinner/gi, '').length;
  });

  // Has either visible text or visible images/svgs
  const hasMedia = await page.locator('img:visible, svg:visible, canvas:visible').count();

  return textLength > 10 || hasMedia > 0;
}

/** Check for stuck loading spinners */
async function hasStuckSpinner(page: Page): Promise<boolean> {
  // Wait a reasonable time then check for common spinner patterns
  await page.waitForTimeout(2000);

  const spinnerVisible = await page
    .locator(
      '[data-testid="loading"], [data-testid="spinner"], ' +
        '.loading, .spinner, [role="progressbar"], ' +
        '.animate-spin, .animate-pulse'
    )
    .first()
    .isVisible()
    .catch(() => false);

  return spinnerVisible;
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

test.describe('Route Loading - All Routes Render', () => {
  test.describe('Content rendering', () => {
    for (const route of ROUTES) {
      const label = route.name ?? route.path;

      test(`${label} renders content (not blank)`, async ({ page }) => {
        const errors = attachErrorListener(page);

        await page.goto(`${BASE_URL}${route.path}`, { waitUntil: 'networkidle' });

        // If the route requires auth and we got redirected to login, that's OK
        if (route.authenticated && page.url().includes('login')) {
          // Auth redirect is expected - route guard works
          return;
        }

        // Page should have visible content
        const hasContent = await hasVisibleContent(page);
        expect(hasContent, `${label} appears blank - possible lazy import failure`).toBe(true);
      });
    }
  });

  test.describe('No JS console errors', () => {
    for (const route of ROUTES) {
      const label = route.name ?? route.path;

      test(`${label} loads without JS errors`, async ({ page }) => {
        const errors = attachErrorListener(page);

        await page.goto(`${BASE_URL}${route.path}`, { waitUntil: 'networkidle' });

        // Filter out known non-critical errors
        const criticalErrors = errors.filter(
          (e) =>
            !e.includes('favicon') &&
            !e.includes('ResizeObserver') &&
            !e.includes('net::ERR_FAILED') // network issues =/= code errors
        );

        expect(
          criticalErrors,
          `JS errors on ${label}:\n${criticalErrors.join('\n')}`
        ).toHaveLength(0);
      });
    }
  });

  test.describe('No stuck loading spinners', () => {
    for (const route of ROUTES.filter((r) => !r.authenticated)) {
      const label = route.name ?? route.path;

      test(`${label} resolves loading state`, async ({ page }) => {
        await page.goto(`${BASE_URL}${route.path}`, { waitUntil: 'networkidle' });

        const stuck = await hasStuckSpinner(page);
        expect(stuck, `${label} has a stuck loading spinner`).toBe(false);
      });
    }
  });

  test.describe('Route transitions', () => {
    test('navigating between routes works without errors', async ({ page }) => {
      const errors = attachErrorListener(page);
      const publicRoutes = ROUTES.filter((r) => !r.authenticated);

      if (publicRoutes.length < 2) {
        test.skip();
        return;
      }

      // Navigate to first route
      await page.goto(`${BASE_URL}${publicRoutes[0].path}`, { waitUntil: 'networkidle' });

      // Click through to second route using a link (client-side navigation)
      const secondPath = publicRoutes[1].path;
      const link = page.locator(`a[href="${secondPath}"], a[href*="${secondPath}"]`).first();

      if (await link.isVisible().catch(() => false)) {
        await link.click();
        await page.waitForLoadState('networkidle');

        // Should have navigated
        expect(page.url()).toContain(secondPath);

        // Should have content
        const hasContent = await hasVisibleContent(page);
        expect(hasContent, 'Blank page after client-side navigation').toBe(true);
      } else {
        // Direct navigation fallback
        await page.goto(`${BASE_URL}${secondPath}`, { waitUntil: 'networkidle' });
        const hasContent = await hasVisibleContent(page);
        expect(hasContent, 'Blank page on direct navigation').toBe(true);
      }

      // No errors during transitions
      const criticalErrors = errors.filter(
        (e) => !e.includes('favicon') && !e.includes('ResizeObserver')
      );
      expect(criticalErrors).toHaveLength(0);
    });
  });

  test.describe('Chunk loading & error boundaries', () => {
    test('simulated chunk failure shows error boundary', async ({ page }) => {
      const errors = attachErrorListener(page);

      // Block JS chunk requests to simulate network failure
      await page.route('**/*.chunk.js', (route) => route.abort('failed'));
      await page.route('**/assets/*.js', (route) => {
        // Only block lazy chunks, not the main bundle
        if (route.request().url().includes('lazy') || route.request().url().includes('chunk')) {
          return route.abort('failed');
        }
        return route.continue();
      });

      const lazyRoute = ROUTES.find((r) => r.authenticated !== true) ?? ROUTES[0];
      if (!lazyRoute) {
        test.skip();
        return;
      }

      await page.goto(`${BASE_URL}${lazyRoute.path}`, { waitUntil: 'domcontentloaded' });
      await page.waitForTimeout(3000);

      // Should show SOMETHING - error boundary, fallback, or retry message
      // Should NOT be a completely blank white page
      const bodyText = await page.evaluate(() => document.body.innerText?.trim() ?? '');
      // A blank page has essentially no text - error boundary should show something
      // We're lenient here: even a small amount of text means the app handled it
      const pageNotBlank = bodyText.length > 0;
      expect(pageNotBlank, 'Chunk load failure resulted in blank page - add error boundary').toBe(
        true
      );
    });
  });

  test.describe('404 handling', () => {
    test('unknown route shows 404 page', async ({ page }) => {
      const errors = attachErrorListener(page);

      await page.goto(`${BASE_URL}/__nonexistent_route_test__`, { waitUntil: 'networkidle' });

      // Should show some content (not blank)
      const hasContent = await hasVisibleContent(page);
      expect(hasContent, 'No 404 page - unknown route shows blank screen').toBe(true);

      // Should ideally contain "not found" text
      const pageText = await page.evaluate(() => document.body.innerText.toLowerCase());
      const has404Indicator =
        pageText.includes('not found') ||
        pageText.includes('404') ||
        pageText.includes('does not exist') ||
        pageText.includes('page missing');
      expect(has404Indicator, 'Unknown route should indicate page not found').toBe(true);
    });
  });

  test.describe('Performance thresholds', () => {
    for (const route of ROUTES.filter((r) => !r.authenticated).slice(0, 5)) {
      const label = route.name ?? route.path;

      test(`${label} loads within ${LOAD_TIMEOUT}ms`, async ({ page }) => {
        const start = Date.now();

        await page.goto(`${BASE_URL}${route.path}`, {
          waitUntil: 'networkidle',
          timeout: LOAD_TIMEOUT,
        });

        const elapsed = Date.now() - start;
        expect(elapsed, `${label} took ${elapsed}ms (limit: ${LOAD_TIMEOUT}ms)`).toBeLessThan(
          LOAD_TIMEOUT
        );
      });
    }
  });
});
