/**
 * Documentation Generator Hook
 *
 * Automatically generates documentation when phase development plans
 * or roadmaps are created. Creates:
 * - EXECUTIVE_SUMMARY.md - High-level overview for stakeholders
 * - phase-executor.md - Detailed execution instructions for Claude
 * - README.md - Documentation in the plan directory
 *
 * Event: PostToolUse
 * Triggers: After Write operations on PROGRESS.json or ROADMAP.json
 */

const fs = require('fs');
const path = require('path');

// Configuration
const CONFIG = {
  triggerFiles: ['PROGRESS.json', 'ROADMAP.json'],
  outputDir: null, // Same directory as the JSON file
  templates: {
    executiveSummary: 'EXECUTIVE_SUMMARY.md',
    phaseExecutor: 'phase-executor.md',
    readme: 'README.md',
  },
};

/**
 * Load commit configuration from tech-stack.json
 * Returns the coAuthors config or defaults (disabled)
 */
function loadCommitConfig(projectRoot) {
  const techStackPaths = [
    path.join(projectRoot, '.claude', 'config', 'tech-stack.json'),
    path.join(projectRoot, '.claude', 'tech-stack.json'),
    path.join(projectRoot, 'tech-stack.json'),
  ];

  for (const configPath of techStackPaths) {
    if (fs.existsSync(configPath)) {
      try {
        const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
        return config.commit?.coAuthors || { enabled: false, authors: [] };
      } catch (e) {
        // Invalid JSON, use defaults
      }
    }
  }

  // Default: co-authors disabled
  return { enabled: false, authors: [] };
}

/**
 * Check if file is a trigger file
 */
function isTriggerFile(filePath) {
  if (!filePath) return false;
  const fileName = path.basename(filePath);
  return CONFIG.triggerFiles.includes(fileName);
}

/**
 * Generate executive summary from PROGRESS.json
 */
function generateExecutiveSummary(progressData, projectRoot) {
  const {
    plan_id,
    plan_name,
    description,
    status,
    estimated_success_rate,
    phases,
    metadata,
    risk_assessment,
  } = progressData;

  let md = `# ${plan_name} - Executive Summary\n\n`;
  md += `## Overview\n\n`;
  md += `${description || 'No description provided.'}\n\n`;

  // Status badge
  const statusEmoji = status === 'completed' ? '\\u2705' : status === 'in_progress' ? '\\u{1F504}' : '\\u23F3';
  md += `**Status:** ${statusEmoji} ${status?.toUpperCase() || 'PLANNING'}\n`;
  md += `**Plan ID:** \`${plan_id}\`\n`;
  md += `**Estimated Success Rate:** ${Math.round((estimated_success_rate || 0.95) * 100)}%\n\n`;

  // Phase overview table
  if (phases && phases.length > 0) {
    md += `## Phases\n\n`;
    md += `| Phase | Status | Tasks | Effort |\n`;
    md += `|-------|--------|-------|--------|\n`;

    phases.forEach((phase, index) => {
      const phaseStatus = phase.status || 'pending';
      const taskCount = phase.tasks?.length || 0;
      const completedTasks = phase.tasks?.filter((t) => t.status === 'completed').length || 0;
      const effort = phase.estimated_effort || 'TBD';
      const emoji = phaseStatus === 'completed' ? '\\u2705' : phaseStatus === 'in_progress' ? '\\u{1F504}' : '\\u2B1C';
      md += `| ${emoji} ${phase.name} | ${phaseStatus} | ${completedTasks}/${taskCount} | ${effort} |\n`;
    });

    md += `\n`;
  }

  // Success criteria
  if (phases && phases.some((p) => p.success_criteria?.length > 0)) {
    md += `## Success Criteria\n\n`;
    phases.forEach((phase) => {
      if (phase.success_criteria && phase.success_criteria.length > 0) {
        md += `### ${phase.name}\n`;
        phase.success_criteria.forEach((criteria) => {
          md += `- [ ] ${criteria}\n`;
        });
        md += `\n`;
      }
    });
  }

  // Risk assessment
  if (risk_assessment) {
    md += `## Risk Assessment\n\n`;
    if (risk_assessment.high_risk_areas && risk_assessment.high_risk_areas.length > 0) {
      md += `### High Risk Areas\n`;
      risk_assessment.high_risk_areas.forEach((risk) => {
        md += `- ${risk}\n`;
      });
      md += `\n`;
    }
    if (risk_assessment.mitigation_strategies && risk_assessment.mitigation_strategies.length > 0) {
      md += `### Mitigation Strategies\n`;
      risk_assessment.mitigation_strategies.forEach((strategy) => {
        md += `- ${strategy}\n`;
      });
      md += `\n`;
    }
  }

  // Metadata
  if (metadata) {
    md += `## Metadata\n\n`;
    md += `- **Total Tasks:** ${metadata.total_tasks || 'N/A'}\n`;
    md += `- **Files Affected:** ${metadata.total_files_affected || 'N/A'}\n`;
    md += `- **Estimated LOC:** ${metadata.estimated_loc || 'N/A'}\n`;
    if (metadata.agents_used && metadata.agents_used.length > 0) {
      md += `- **Agents Used:** ${metadata.agents_used.join(', ')}\n`;
    }
    md += `\n`;
  }

  md += `---\n\n`;
  md += `*Generated by CCASP Documentation Generator*\n`;
  md += `*Plan ID: ${plan_id}*\n`;

  return md;
}

/**
 * Generate phase executor instructions from PROGRESS.json
 */
function generatePhaseExecutor(progressData, projectRoot) {
  const { plan_id, plan_name, phases, testing_config } = progressData;

  let md = `# ${plan_name} - Phase Executor Agent\n\n`;
  md += `You are executing the **${plan_name}** phased development plan. `;
  md += `Your goal is to implement the plan systematically, tracking progress in PROGRESS.json.\n\n`;

  // Current plan location
  md += `## Current Plan Location\n\n`;
  md += `- PROGRESS.json: \`.claude/docs/${plan_id}/PROGRESS.json\`\n`;
  md += `- Executive Summary: \`.claude/docs/${plan_id}/EXECUTIVE_SUMMARY.md\`\n\n`;

  // Phase execution protocol
  md += `## Phase Execution Protocol\n\n`;
  md += `### Before Starting Any Phase\n\n`;
  md += `1. Read PROGRESS.json to check current status\n`;
  md += `2. Verify all dependency phases are completed\n`;
  md += `3. Review the specific tasks for the target phase\n\n`;

  md += `### During Phase Execution\n\n`;
  md += `1. Mark the phase status as "in_progress" in PROGRESS.json\n`;
  md += `2. Use TodoWrite to track individual tasks\n`;
  md += `3. Mark each task complete immediately after finishing\n`;
  md += `4. Run tests/lint after each significant change\n\n`;

  md += `### After Completing a Phase\n\n`;
  md += `1. Update phase status to "completed" in PROGRESS.json\n`;
  md += `2. Run validation checks for success criteria\n`;
  md += `3. Commit changes with descriptive message\n`;
  md += `4. Report completion status\n\n`;

  // Phase-specific instructions
  if (phases && phases.length > 0) {
    md += `## Phase-Specific Instructions\n\n`;

    phases.forEach((phase, index) => {
      md += `### Phase ${index + 1}: ${phase.name}\n\n`;

      if (phase.description) {
        md += `${phase.description}\n\n`;
      }

      // Key files
      const files = extractFilesFromTasks(phase.tasks || []);
      if (files.length > 0) {
        md += `**Key Files:**\n`;
        files.forEach((file) => {
          md += `- \`${file}\`\n`;
        });
        md += `\n`;
      }

      // Tasks
      if (phase.tasks && phase.tasks.length > 0) {
        md += `**Tasks:**\n`;
        phase.tasks.forEach((task) => {
          const checkbox = task.status === 'completed' ? '[x]' : '[ ]';
          md += `- ${checkbox} ${task.id}: ${task.title}\n`;
          if (task.details) {
            md += `  - ${task.details}\n`;
          }
        });
        md += `\n`;
      }

      // Success criteria
      if (phase.success_criteria && phase.success_criteria.length > 0) {
        md += `**Success Validation:**\n`;
        phase.success_criteria.forEach((criteria) => {
          md += `- ${criteria}\n`;
        });
        md += `\n`;
      }

      // Dependencies
      if (phase.dependencies && phase.dependencies.length > 0) {
        md += `**Dependencies:** ${phase.dependencies.join(', ')}\n\n`;
      }

      // Recommended agents
      if (phase.agents_recommended && phase.agents_recommended.length > 0) {
        md += `**Recommended Agents:** ${phase.agents_recommended.join(', ')}\n\n`;
      }
    });
  }

  // Testing configuration
  if (testing_config) {
    md += `## Testing Configuration\n\n`;

    if (testing_config.ralph_loop?.enabled) {
      md += `### Ralph Loop\n`;
      md += `- **Max Iterations:** ${testing_config.ralph_loop.max_iterations || 5}\n`;
      if (testing_config.ralph_loop.test_commands) {
        md += `- **Commands:**\n`;
        Object.entries(testing_config.ralph_loop.test_commands).forEach(([key, cmd]) => {
          md += `  - ${key}: \`${cmd}\`\n`;
        });
      }
      md += `\n`;
    }

    if (testing_config.e2e_tests?.enabled) {
      md += `### E2E Tests\n`;
      md += `- **Framework:** ${testing_config.e2e_tests.framework || 'playwright'}\n`;
      md += `- **Coverage Target:** ${testing_config.e2e_tests.coverage_target || 80}%\n\n`;
    }
  }

  // Agent deployment strategy
  md += `## Agent Deployment Strategy\n\n`;
  md += `| Task Type | Agent |\n`;
  md += `|-----------|-------|\n`;
  md += `| File exploration | Explore agent |\n`;
  md += `| Code generation | general-purpose agent |\n`;
  md += `| Testing | Bash agent |\n`;
  md += `| Template processing | general-purpose agent |\n\n`;

  // Commit message template
  md += `## Commit Message Template\n\n`;
  md += '```\n';
  md += `feat(${plan_id.split('-')[0]}): Phase N - [phase name]\n\n`;
  md += `- [Task P1.1]: [what was done]\n`;
  md += `- [Task P1.2]: [what was done]\n`;

  // Add co-author lines only if configured
  const coAuthorConfig = loadCommitConfig(projectRoot);
  if (coAuthorConfig.enabled && coAuthorConfig.authors && coAuthorConfig.authors.length > 0) {
    md += `\n`;
    for (const author of coAuthorConfig.authors) {
      if (author.name && author.email) {
        md += `Co-Authored-By: ${author.name} <${author.email}>\n`;
      }
    }
  }

  md += '```\n\n';

  md += `---\n\n`;
  md += `*Phase Executor Agent - ${plan_name}*\n`;
  md += `*Use /phase-track to monitor progress*\n`;

  return md;
}

/**
 * Generate roadmap documentation from ROADMAP.json
 */
function generateRoadmapDocs(roadmapData, projectRoot) {
  const {
    roadmap_slug,
    roadmap_name,
    primary_goal,
    projects,
    total_projects,
    completed_projects,
    dependency_graph,
    created_at,
  } = roadmapData;

  let md = `# ${roadmap_name}\n\n`;
  md += `## Overview\n\n`;
  md += `${primary_goal || 'No goal specified.'}\n\n`;

  // Progress summary
  const progressPercent = total_projects > 0 ? Math.round((completed_projects / total_projects) * 100) : 0;
  md += `**Progress:** ${completed_projects || 0} / ${total_projects || 0} phases complete (${progressPercent}%)\n`;
  md += `**Roadmap ID:** \`${roadmap_slug}\`\n`;
  md += `**Created:** ${created_at || new Date().toISOString()}\n\n`;

  // Dependency graph (Mermaid)
  if (projects && projects.length > 0) {
    md += `## Dependency Graph\n\n`;
    md += '```mermaid\n';
    md += 'graph TD\n';

    // Add nodes
    projects.forEach((project, index) => {
      const statusClass = project.status === 'completed' ? ':::completed' : project.status === 'in_progress' ? ':::inprogress' : '';
      md += `    P${index + 1}["${project.project_name}"]${statusClass}\n`;
    });

    // Add edges from dependency graph
    if (dependency_graph) {
      Object.entries(dependency_graph).forEach(([targetId, deps]) => {
        const targetIndex = projects.findIndex((p) => p.project_id === targetId);
        if (targetIndex >= 0 && deps) {
          deps.forEach((depId) => {
            const depIndex = projects.findIndex((p) => p.project_id === depId);
            if (depIndex >= 0) {
              md += `    P${depIndex + 1} --> P${targetIndex + 1}\n`;
            }
          });
        }
      });
    }

    // Add style definitions
    md += '\n    classDef completed fill:#22c55e,stroke:#16a34a,color:#fff\n';
    md += '    classDef inprogress fill:#3b82f6,stroke:#2563eb,color:#fff\n';
    md += '```\n\n';
  }

  // Phase details
  if (projects && projects.length > 0) {
    md += `## Phases\n\n`;

    projects.forEach((project, index) => {
      const statusEmoji = project.status === 'completed' ? '\\u2705' : project.status === 'in_progress' ? '\\u{1F504}' : '\\u2B1C';
      md += `### ${statusEmoji} Phase ${index + 1}: ${project.project_name}\n\n`;

      if (project.description) {
        md += `${project.description}\n\n`;
      }

      md += `- **Priority:** ${project.priority || 'MEDIUM'}\n`;
      md += `- **Estimated Effort:** ${project.estimated_effort_hours || 'TBD'} hours\n`;

      if (project.phase_dev_config?.progress_json_path) {
        md += `- **Progress File:** \`${project.phase_dev_config.progress_json_path}\`\n`;
      }

      if (project.dependencies && project.dependencies.length > 0) {
        const depNames = project.dependencies
          .map((depId) => {
            const dep = projects.find((p) => p.project_id === depId);
            return dep ? dep.project_name : depId;
          })
          .join(', ');
        md += `- **Depends On:** ${depNames}\n`;
      }

      md += `\n`;
    });
  }

  // Commands
  md += `## Commands\n\n`;
  md += '```bash\n';
  md += `# View roadmap status\n`;
  md += `/roadmap-status ${roadmap_slug}\n\n`;
  md += `# Track individual phase\n`;
  md += `/phase-track <phase-id>\n\n`;
  md += `# Sync with GitHub\n`;
  md += `ccasp roadmap sync ${roadmap_slug}\n`;
  md += '```\n\n';

  md += `---\n\n`;
  md += `*Generated by CCASP Roadmap System*\n`;

  return md;
}

/**
 * Extract unique files from tasks
 */
function extractFilesFromTasks(tasks) {
  const files = new Set();
  tasks.forEach((task) => {
    if (task.file) {
      files.add(task.file);
    }
  });
  return Array.from(files);
}

/**
 * Main hook handler
 */
async function documentationGeneratorHook(context) {
  const { tool, toolInput, projectRoot, hookType } = context;

  // Only process PostToolUse events
  if (hookType !== 'PostToolUse') {
    return { continue: true };
  }

  // Only track Write operations
  if (tool !== 'Write') {
    return { continue: true };
  }

  const filePath = toolInput?.file_path || '';

  // Only process trigger files
  if (!isTriggerFile(filePath)) {
    return { continue: true };
  }

  const fileName = path.basename(filePath);
  const fileDir = path.dirname(filePath);

  // Read the JSON file
  let jsonData;
  try {
    const fullPath = path.isAbsolute(filePath) ? filePath : path.join(projectRoot, filePath);
    jsonData = JSON.parse(fs.readFileSync(fullPath, 'utf8'));
  } catch (error) {
    return { continue: true };
  }

  const generatedFiles = [];

  if (fileName === 'PROGRESS.json') {
    // Generate executive summary
    const summaryContent = generateExecutiveSummary(jsonData, projectRoot);
    const summaryPath = path.join(fileDir, CONFIG.templates.executiveSummary);
    fs.writeFileSync(summaryPath, summaryContent, 'utf8');
    generatedFiles.push(CONFIG.templates.executiveSummary);

    // Generate phase executor instructions
    const executorContent = generatePhaseExecutor(jsonData, projectRoot);
    const executorPath = path.join(fileDir, CONFIG.templates.phaseExecutor);
    fs.writeFileSync(executorPath, executorContent, 'utf8');
    generatedFiles.push(CONFIG.templates.phaseExecutor);
  } else if (fileName === 'ROADMAP.json') {
    // Generate roadmap README
    const readmeContent = generateRoadmapDocs(jsonData, projectRoot);
    const readmePath = path.join(fileDir, CONFIG.templates.readme);
    fs.writeFileSync(readmePath, readmeContent, 'utf8');
    generatedFiles.push(CONFIG.templates.readme);
  }

  if (generatedFiles.length > 0) {
    return {
      continue: true,
      message: `Documentation generated: ${generatedFiles.join(', ')}`,
      metadata: {
        generatedFiles,
        sourceFile: fileName,
      },
    };
  }

  return { continue: true };
}

module.exports = documentationGeneratorHook;

// Export for testing
module.exports.generateExecutiveSummary = generateExecutiveSummary;
module.exports.generatePhaseExecutor = generatePhaseExecutor;
module.exports.generateRoadmapDocs = generateRoadmapDocs;
